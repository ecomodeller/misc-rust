window.SIDEBAR_ITEMS = {"mod":[["affine_ops","Composable affine operations such as rotate, scale, skew, and translate"],["area","Calculate the area of the surface of a `Geometry`."],["bearing","Calculate the bearing to another `Point`, in degrees."],["bool_ops","Boolean Ops such as union, xor, difference;"],["bounding_rect","Calculate the bounding rectangle of a `Geometry`."],["centroid","Calculate the centroid of a `Geometry`."],["chaikin_smoothing","Smoothen `LineString`, `Polygon`, `MultiLineString` and `MultiPolygon` using Chaikins algorithm."],["chamberlain_duquette_area","Calculate the signed approximate geodesic area of a `Geometry`."],["closest_point","Calculate the closest `Point` between a `Geometry` and an input `Point`."],["concave_hull","Calculate the concave hull of a `Geometry`."],["contains","Determine whether `Geometry` `A` completely encloses `Geometry` `B`."],["convert","Convert the type of a geometry’s coordinate value."],["convex_hull","Calculate the convex hull of a `Geometry`."],["coordinate_position","Determine whether a `Coord` lies inside, outside, or on the boundary of a geometry."],["coords_iter","Iterate over geometry coordinates."],["densify","Densify linear geometry components"],["dimensions","Dimensionality of a geometry and its boundary, based on OGC-SFA."],["euclidean_distance","Calculate the minimum Euclidean distance between two `Geometries`."],["euclidean_length","Calculate the length of a planar line between two `Geometries`."],["extremes","Calculate the extreme coordinates and indices of a geometry."],["frechet_distance","Calculate the Frechet distance between two `LineStrings`."],["geodesic_distance","Calculate the Geodesic distance between two `Point`s."],["geodesic_intermediate","Calculate a new `Point` lying on a Geodesic arc between two `Point`s."],["geodesic_length","Calculate the Geodesic length of a line."],["haversine_destination","Calculate a destination `Point`, given a distance and a bearing."],["haversine_distance","Calculate the Haversine distance between two `Geometries`."],["haversine_intermediate","Calculate a new `Point` lying on a Great Circle arc between two `Point`s."],["haversine_length","Calculate the Haversine length of a Line."],["interior_point","Calculate a representative `Point` inside a `Geometry`"],["intersects","Determine whether `Geometry` `A` intersects `Geometry` `B`."],["is_convex","Determines whether a `LineString` is convex."],["k_nearest_concave_hull","Calculate concave hull using k-nearest algorithm"],["kernels","Kernels to compute various predicates"],["line_interpolate_point","Interpolate a point along a `Line` or `LineString`."],["line_intersection","Computes the intersection of two Lines."],["line_locate_point","Locate a point along a `Line` or `LineString`."],["lines_iter","Iterate over the lines in a geometry."],["map_coords","Apply a function to all `Coord`s of a `Geometry`."],["orient","Orient a `Polygon`’s exterior and interior rings."],["outlier_detection","Detect outliers in a group of points using LOF"],["relate","Relate two geometries based on DE-9IM"],["remove_repeated_points","Remove (consecutive) repeated points"],["rotate","Rotate a `Geometry` by an angle given in degrees."],["scale","Scale a `Geometry` up or down by a factor"],["simplify","Simplify `Geometries` using the Ramer-Douglas-Peucker algorithm."],["simplifyvw","Simplify `Geometries` using the Visvalingam-Whyatt algorithm. Includes a topology-preserving variant."],["skew","Skew a `Geometry` by shearing it at angles along the x and y dimensions"],["sweep","Planar sweep algorithm and related utils"],["translate","Translate a `Geometry` along the given offsets."],["vincenty_distance","Calculate the Vincenty distance between two `Point`s."],["vincenty_length","Calculate the Vincenty length of a `LineString`."],["winding_order","Calculate and work with the winding order of `Linestring`s."],["within","Determine whether `Geometry` `A` is completely within by `Geometry` `B`."]],"trait":[["MapCoords","Map a function over all the coordinates in an object, returning a new one"],["MapCoordsInPlace",""],["MapCoordsInplace","Map a function over all the coordinates in an object in place"],["TryMapCoords","Map a fallible function over all the coordinates in a geometry, returning a Result"],["TryMapCoordsInplace",""]]};